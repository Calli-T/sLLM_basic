배우는것
1. 효율적인 배치전략

2. 동일한 연산, 성능 하락 없음, 추론 속도를 올리는법
-플래시 어텐션
-페이지 어텐션

3. 효율적인 추론 전략
-커널 퓨전
-추측 디코딩
-상대적 위치 인코딩

259p
효율적인 배치 전략
{   효율적인 배치 전략
    문제: 언어모델은 한 번에 한 토큰씩 생성하므로,
    몇 개의 추가 토큰을 생성할지 예측이 어려움
    한꺼번에 많이 땡겨야 좋은데, 저런 이유로 배치가 어려움
    (배치라는게, 몇 개의 프롬프트를 동시에 처리하는 얘기인듯)

    {   다음과 같은 배치 전략이 있음
        일반 배치(정적 배치): 한 번에 N개의 입력을 받아 모두 추론이 끝날 때까지 기다리는 방식
        - 가장 길게 생성된 시퀀스가 끝날 때까지, 생성이 완료된 시퀀스도 반환을 기다려야한다.
        - 당연히 먼저 끝난 시퀀스 만큼 놀게되므로, 효율적이지 못하다.

        동적 배치: 비슷한 시간대에 들어오는 요청을 하나의 배치로 묶어 배치 크기를 키우는 전략
        - 하나씩 처리하면 다음 사용자는 먼저 들어온 요청이 끝날 때까지 기다려야한다
        - 받은대로 바로 추론 시작하지말고 일정 시간을 대기하면서 다른 사용자의 요청을 기다리면, 한 번에 처리가능
        - 일찍 온 사용자가 몇 ms정도 지연되는건 무시하기로 한다.
        - 온라인 서빙에서 배치 크기를 키워 처리량을 높일 수 있다.
        - 그러나 토큰 길이 차이로 인한문제, 즉 일반 배치에서 문제가 된 요소가 해결된건 아님

        연속 배치: 한 번 들어온 배치가 모두 끝날 때까지 기다리지 않고,
        하나의 토큰이 생성될 때마다 생성이 종료된 문장은 제거하고, 새로운 문장을 추가한다.
        토큰 1개 생성할 때마다 배치 내부 검사,
        생성완료된 문장은 새로운 값으로 대체하고 다시 생성
        무한 반복
        - 새로운 데이터를 배치에 추가할 때 고려할 사항: 사전 연산과 디코딩은 처리 방식(과 오버헤드)이 다르므로,
        문장 완료에 무조건 추가하는 것은 아니고 처리 중 / 대기 중 문장을 비율에 조건을 조건을 걸어 임계값 너머에서만 처리할 수도 있음
        ※ 일반적으로 디코딩이 사전 연산보다는 시간이 많이 걸린다고 함
        ※※ 디코딩은 단어 생성/(최종 단어 softmax)확률 계산/시퀀스 완성, 사전 연산은 토큰화/임베딩/패딩 등등이 있다고 한다.
        ※※※※ huggingface의 Text-Generation-Inference의 waiting_served_ratio 옵션등이 있다고함
    }

    결론: 연속 배치를 써서 여러 프롬프트를 동시에 처리하되, 사전 연산과 디코딩의 오버헤드를 잘따져서 최적의 효율에서 배치를 갱신하라
}