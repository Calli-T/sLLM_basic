서문: 셀프 어텐션은 쿼리와 키 벡터 사이의 관련도를 계산해 새롭게 토큰 임베딩을 조정
성능이 높으나 많은 연산이 필요하다.
플래시 어텐션을 쓰면? 동일한 계산, 메모리 사용량 줄이고, 속도를 높인다.

절대적 위치 임베딩이란? 토큰에 위치 정보를, 위치에 따라 동일한 임베딩을 추가
단점은? 학습 데이터보다 긴 입력 데이터가 들어올 경우 성능이 크게 저하된다.
토큰 사이의 상대적 위치 정보를 추가하는 '상대적 위치 인코딩.

263p
{   플래시어텐션
    한 줄 요약: 어텐션 행렬을 메모리에 넣었다 뺐다 하면 메모리 접근 시간이 너무 오래걸려서, 블록단위로 나눠서 한 번 만든 어텐션 행렬은 싹 다 처리하고 메모리에서 빼는거

    {   플래시어텐션은 왜 개발되었나?
        트랜스포머 아키텍처의 연산량은 시퀀스의 길이의 제곱에 비례함
        ※ (토큰 임베딩의 길이가 [T, d_inner]이고, [d_inner, d]인 W_Q와 W_K와 선형곱한, 그리고 하나만 전치한 행렬 MQ와 MK^T를 곱할 때, 이들은 각각 [T, d], [d, T] 행렬이므로 시간 복잡도가 T^2에 비례한다)
        이를 시퀀스 길이에 비례하도록 개선한 것이 플래시어텐션

        책에서 쿼리와 키 행렬이 [N, d]라는건, 가중치 행렬을 지나고 나서 결과 값 행렬의 크기가 그렇단 소리다
        어텐션 행렬의 크기가 [N,N]이다

        그리고 요새 더 긴 글, 오디오, 비디오 등등 처리 시퀀스가 길어지는 중이다.

        {   어텐션 행렬이 왜 다른 연산보다 연산량이 많은데도 소모 시간이 적은가?
            이후 마스크, 소프트맥스, 드롭아웃, 행렬곱 등등을 연산하는데,
            뒤의 네 작업이 걸리는 시간이 어텐션 행렬 생성에 드는 시간보다 길지만,
            연산량 자체는 어텐션 행렬 생성이 더 많다.
            이런 일이 일어나려면, GPU의 VRAM에서 읽거나 쓰는 작업이 연산 보다 시간이 오래 걸려야 성립한다.
            뒤 작업은 공통적으로 어텐션 행렬에 취하는 연산이다.
            그리고 어텐션 행렬 <- 얘는 크기가 크다

            결론: 연산보단 메모리에 쓰고 읽는데 시간이 많이 걸리는 편인데,
            어텐션연산에서 어텐션 행렬을 만드는 작업 그 자체를 제외하고는
            큰 데이터(= 어텐션 행렬)을 메모리에 넣으려 들어서 시간이 많이 걸린다
        }

        결론1: 시퀀스가 길어지면 시간이 제곱으로 길어진다.
        결론2: 어텐션 행렬을 넣었다 뺐다 하면 메모리 접근 시간이 너무 커진다
    }

    {   그래서 어떻게 할건데?
        1. 계산을 블록 단위로 한다. 전체 어텐션 행렬을 쓰거나 읽지 않는 방식이다.
        2. HBM이 아니라 SRAM에 데이터를 읽고 쓰면서 빠르게 연산

        ※??? 여기 내부순회, 외부 순회가 정확히 뭔지 까지는 잘 모르겠다.
        HBM에서 QKV를 보관해둠, (블럭 단위로) QK^T를 SRAM에서 계산, 이걸 다시 V와 계산, 계산 끝나면 HBM에 저장
    }

    {   소프트맥스를 블럭단위로 연산하는 트릭
        266p 나와 있다
        소프트 맥스는 e를 밑으로, 값을 지수로 사용한 것을 모두 더하여 분모로, 각각을 분자로 올리면 해당 값에 대한 확률이 나오는 함수이다.
        분모는 모두 더하고, 분자는 concatenate하는 방식인듯하다
        지수가 너무 커지는 걸 막기위해 norm하는 트릭도 있다
    }

    {   어떻게 얼마나 빨라지나?
        N*N 크기의 행렬을 저장하지 않고 어텐션 연산이 가능
        역전파에서는 순전파의 N*N행렬이 필요한다. 이건 다시 다시 계산하는 방식으로 문제를 해결
        계산량이 증가하나, 메모리 읽고 쓰는 양이 1/9 정도로 줄어서 실행 시간이 1/6~1/5정도로 줄어든다고함
    }

    아키텍쳐나, 내차 등 '정확히' 어떻게 돌아가는지는 좀 나중에 알아보자
    확실히 쉬운 정보는 아니구나
}